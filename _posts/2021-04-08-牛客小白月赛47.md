---
title: 牛客小白月赛47
date: 2022-04-05 15:27:00 +0800
categories: [牛客]
tags: [牛客小白赛] [题解]
pin: true
author: 朝朝暮暮

toc: true
comments: true
typora-root-url: ../../zhaomuwendao.github.io
math: false
mermaid: true

image:
  src: /assets/blog_res/2021-04-05-2020天梯模拟赛.assets/huoshan.jpg
  alt: 签约成功
---



# 感谢关注



## A.牛牛的装球游戏

![image-20220408230022599](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408230022599.png)

![image-20220408230041760](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408230041760.png)

```c++
#include<iostream>
using namespace std;
int main()
{
	int n;
	double pi = 3.141592653589;
	cin >> n;
	while (n--)
	{
		int r, h;
		cin >> r >> h;
		int t = h / r/2;
		double data = 0;
		data += pi * r * r * h;
		data -= (4.0 / 3) * pi * r * r * r*t;
		printf("%.3lf\n", data);
	}
	return 0;
}
/*
	简单的签到题目
*/
```

## B.牛牛的数字集合

![image-20220408231222630](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408231222630.png)

![image-20220408231230028](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408231230028.png)

```c++
#include<iostream>
using namespace std;
long mod=1e+9+7;
int main()
{
	long long sum = 1;
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		int t;
		cin >> t;
		sum= sum*t%mod;
	}
	cout << sum%mod << endl;
	return 0;
}
```

## C.小猫排队

![image-20220408230211050](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408230211050.png)

![image-20220408230220385](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408230220385.png)

![image-20220408230228429](/assets/blog_res/2021-04-08-牛客小白月赛47.assets/image-20220408230228429.png)

```c++
#include<iostream>
using namespace std;
#include<vector>
#include<algorithm>
int main()
{
	int n;
	cin >> n;
	vector<int>data(n);//用来获取数据
	int index = -1;
	int cc = 0;
	for (int i = 0; i < n; i++)
		cin >> data[i];
	int key;//获取小猫的萌值
	cin >> key;
	reverse(data.begin(), data.end());//反转数据方便操作
	vector<int>max_index;
	for (int i=0;i<n;i++)
	{
		if (data[i] > key) {
			max_index.push_back(i);//获取可以交换位置的下标
		}
	}
	int start = 0;//交换位置数组的下标
	while (index != n)
	{
		if (start < max_index.size() && max_index[start] < n)
		{//start要在0到max_index-1之间，并且小猫跳的位置要小于末尾的位置
			index = max_index[start];
			start++;
		}
		n--;
		cc++;
	}
	cout << cc << endl;
}
/*
	阅读题目，我们可以使用模拟的方法，我们可以将数据存入vector，然后在反
转，问题就转化为小猫跳到n坐标需要的次数，每次n--意味着开头元素的出列，然
后用max_index存放小猫可以跳跃的位置，如果跳跃位置上的元素没有出列，那么
小猫就会跳到这个元素
*/
```

