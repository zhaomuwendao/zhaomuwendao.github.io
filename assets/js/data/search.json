[ { "title": "牛客小白月赛48", "url": "/posts/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B48/", "categories": "牛客", "tags": "牛客小白赛, 题解", "date": "2022-04-22 04:00:00 +0000", "snippet": "感谢各位的观看A-孤独的数组#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;int main(){ int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;int&amp;gt;data(n); for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; data[i]; int flag = 1; for (int i = 1; i &amp;lt; n; i++) { if (__gcd(data[i], data[i - 1]) != 1) { flag = 0; break; } } if (flag) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;} 如果a[i]和a[i-1]的公约数不为1，那么不管你怎么乘以一个非零的数字，题目的公约数永远是之前的公约数或者更大B-博弈大师#include &amp;lt;iostream&amp;gt;using namespace std;typedef long long ll;int main(){ int t; cin &amp;gt;&amp;gt; t; while (t--) { ll n, a, b; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b; ll l = 0, r = 1e9; while (r - l &amp;gt; 1) { ll mid = (l + r) / 2; if ((mid + 1) * mid / 2 &amp;lt;= n) { l = mid + 1; } else { r = mid; } } if (l % 2) { if (b &amp;gt; a) cout &amp;lt;&amp;lt; &quot;niuniu&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;niumei&quot; &amp;lt;&amp;lt; endl; } else { if (a &amp;gt; b) cout &amp;lt;&amp;lt; &quot;niumei&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;niuniu&quot; &amp;lt;&amp;lt; endl; } }} 博弈题目，我们可以在最后一个回合在使用卡片，如果结果为A赢，那么A的卡片肯定要大于等于B的卡片，因为本题数据量过大，所以使用二分的方式查找" }, { "title": "2021天梯赛决赛", "url": "/posts/2021%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%A8%A1%E6%8B%9F/", "categories": "PTA", "tags": "题解, 天梯赛", "date": "2022-04-20 04:00:00 +0000", "snippet": "" }, { "title": "2021天梯赛决赛", "url": "/posts/2021%E5%A4%A9%E6%A2%AF%E8%B5%9B%E5%86%B3%E8%B5%9B/", "categories": "PTA", "tags": "题解, 天梯赛", "date": "2022-04-20 04:00:00 +0000", "snippet": "感谢各位的观看L11.人与神#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;int main() { cout &amp;lt;&amp;lt; &quot;To iterate is human, to recurse divine.&quot;; return 0;} 签到题2.两小时学完C语言#include&amp;lt;iostream&amp;gt;using namespace std;int main() { int a, b, c; cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c; cout &amp;lt;&amp;lt; a - b * c ; return 0;} 签到题3.强迫症#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;int main() { string s; cin &amp;gt;&amp;gt; s; string res; if (s.size() == 6) { res = s.substr(0, 4) + &quot;-&quot; + s.substr(4, 2); } else { int Year = stoi(s.substr(0, 2)); if (Year &amp;lt; 22) { res += &quot;20&quot; + s.substr(0, 2) + &quot;-&quot; + s.substr(2, 2); } else { res += &quot;19&quot; + s.substr(0, 2) + &quot;-&quot; + s.substr(2, 2); } } cout &amp;lt;&amp;lt; res; return 0;} 简单的字符串修改4.降价提醒机器人#include&amp;lt;iostream&amp;gt;using namespace std;int main() { int n, price; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; price; int flag = 1; while (n--) { double data; cin &amp;gt;&amp;gt; data; if (data &amp;lt; price) { if (flag == 1) { printf(&quot;On Sale! %.1lf&quot;, data); flag = 0; } else printf(&quot;\\nOn Sale! %.1lf&quot;, data); } } return 0;} 简单的字符串处理题目5.大笨钟的心情#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;string&amp;gt;int main() { vector&amp;lt;int&amp;gt;data(24, false); for (int i = 0; i &amp;lt; 24; i++) { cin &amp;gt;&amp;gt; data[i]; } int temp; int flag = 1; while (cin&amp;gt;&amp;gt;temp) { if (temp &amp;lt; 0 || temp&amp;gt;23) { break; } string res; if (data[temp] &amp;gt; 50) { res = &quot;Yes&quot;; } else { res = &quot;No&quot;; } if (flag == 1) { cout &amp;lt;&amp;lt; data[temp] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; res ; flag = 0; } else { cout &amp;lt;&amp;lt; &quot;\\n&quot;&amp;lt;&amp;lt;data[temp] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; res ; } } return 0;} 简单的模拟题目6.吉老师的回归#include &amp;lt;iostream&amp;gt;using namespace std;#include &amp;lt;string&amp;gt;int main(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; int flag = 1; getchar(); while (n--) { string temp; getline(cin, temp); if (temp.find(&quot;qiandao&quot;) != -1 || temp.find(&quot;easy&quot;) != -1) continue; m--; if (m &amp;lt; 0) { if (flag == 1) { cout &amp;lt;&amp;lt; temp; flag = 0; } else { cout &amp;lt;&amp;lt; &quot;\\n&quot; &amp;lt;&amp;lt; temp; } } } if (m &amp;gt;= 0) cout &amp;lt;&amp;lt; &quot;Wo AK le&quot;; return 0;} 签到题7.天梯赛的善良#include &amp;lt;iostream&amp;gt;using namespace std;int main(){ int n; cin &amp;gt;&amp;gt; n; int min = 1000000, max = -1, max_sum = 0, min_sum = 0; while (n--) { int t; cin &amp;gt;&amp;gt; t; if (t &amp;lt; min) { min = t; min_sum = 1; } else if (t == min) min_sum++; if (t &amp;gt; max) { max = t; max_sum = 1; } else if (t == max) max_sum++; } cout &amp;lt;&amp;lt; min &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; min_sum &amp;lt;&amp;lt; &quot;\\n&quot; &amp;lt;&amp;lt; max &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; max_sum; return 0;} 签到题目，我们只需要记录最大值最小值和对应次数即可8.乘法口诀数列#include &amp;lt;iostream&amp;gt;using namespace std;#include &amp;lt;vector&amp;gt;int main(){ int a0, a1, n; cin &amp;gt;&amp;gt; a0 &amp;gt;&amp;gt; a1 &amp;gt;&amp;gt; n; vector&amp;lt;int&amp;gt; data(2*n, 0); int index = 2; data[0] = a0; data[1] = a1; for (int i = 0; i &amp;lt; n; i++) { int temp = data[i] * data[i + 1]; if (temp &amp;lt; 10) data[index++] = temp; else { data[index++] = temp / 10; data[index++] = temp % 10; } } for (int i = 0; i &amp;lt; n - 1; i++) { cout &amp;lt;&amp;lt; data[i] &amp;lt;&amp;lt; &quot; &quot;; } cout &amp;lt;&amp;lt; data[n - 1]; return 0;} 模拟题目，如果乘积大于等于10的话，我们需要推入两个数，反之推入一个数，进行模拟即可L21. 包装机#include &amp;lt;iostream&amp;gt;using namespace std;#include &amp;lt;stack&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;int main(){ int n, m, s_max; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; s_max; vector&amp;lt;queue&amp;lt;char&amp;gt;&amp;gt; data(n); for (int i = 0; i &amp;lt; n; i++) { queue&amp;lt;char&amp;gt; temp; for (int j = 0; j &amp;lt; m; j++) { char ch; cin &amp;gt;&amp;gt; ch; temp.emplace(ch); } data[i] = temp; } int cz; string res; stack&amp;lt;char&amp;gt; s; while (1) { cin &amp;gt;&amp;gt; cz; if (cz == -1) break; if (cz == 0) //抓取东西到流水线 { if (!s.empty()) //当框里东西还有时，没有则不操作 { res.push_back(s.top()); s.pop(); } } else //其他操作 { if (!data[cz - 1].empty()) //当前线上有东西，没有则跳过 { if (s.size() &amp;lt; s_max) //框框没有满，可以继续装 { s.emplace(data[cz - 1].front()); data[cz - 1].pop(); } else //已经满了，需要进行0操作 { res.push_back(s.top()); s.pop(); s.emplace(data[cz - 1].front()); data[cz - 1].pop(); } } } } cout &amp;lt;&amp;lt; res; return 0;} 模拟题目，需要用到栈和队列，每次进行操作的时候如果是抓取操作则需要判断栈是否满，如果满就要强制执行出栈操作，如果对应的没有东西可以抓取则不执行任何操作2.病毒溯源#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;const int N = 1e4 + 10,M=1000010;int h[N],e[M],ne[M],idx;int n;int mx_dep;bool st[N];vector&amp;lt;int&amp;gt; temp,res;void add(int a,int b){ e[idx]=b,ne[idx]=h[a],h[a]=idx++;}void dfs(int u,int dep){ if(dep &amp;gt; mx_dep){ mx_dep=dep; res=temp; } else if(dep == mx_dep &amp;amp;&amp;amp; temp &amp;lt; res){ res=temp; } for(int i=h[u];~i;i=ne[i]){ int j=e[i]; temp.push_back(j); dfs(j, dep + 1); //树形结构，方便回溯 temp.pop_back(); }}int main(){ memset(h,-1,sizeof h); cin&amp;gt;&amp;gt;n; for(int i=0;i&amp;lt;n;i++){ int k;cin&amp;gt;&amp;gt;k; while(k--){ int a;cin&amp;gt;&amp;gt;a; add(i,a); st[a]=true; } } int root=0; while(st[root])root++; dfs(root,1); cout &amp;lt;&amp;lt; mx_dep &amp;lt;&amp;lt; endl; cout&amp;lt;&amp;lt;root; for(int i=0; i &amp;lt; res.size(); i++){ cout &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; res[i]; } return 0;} 使用DFS去获取病毒链的长度，然后如果碰到相等长度需要进行判断哪个小3.清点代码库#include &amp;lt;iostream&amp;gt;using namespace std;#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;map&amp;lt;vector&amp;lt;int&amp;gt;, int&amp;gt; m_map;class Myclass{public: vector&amp;lt;int&amp;gt; data; int ct; bool operator&amp;lt;(const Myclass &amp;amp;v) { if (ct == v.ct) { return data &amp;lt; v.data; } return ct &amp;gt; v.ct; }};int main(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for (int i = 0; i &amp;lt; n; i++) { vector&amp;lt;int&amp;gt; v; int x; for (int j = 0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; x; v.emplace_back(x); } m_map[v]++; } cout &amp;lt;&amp;lt; m_map.size() &amp;lt;&amp;lt; endl; vector&amp;lt;Myclass&amp;gt; res; for (auto i : m_map) { Myclass my; my.ct = i.second; my.data = i.first; res.emplace_back(my); } sort(res.begin(), res.end()); cout &amp;lt;&amp;lt; res[0].ct; for (int i = 0; i &amp;lt; res[0].data.size(); i++) { cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; res[0].data[i]; } for (int i = 1; i &amp;lt; res.size(); i++) { cout &amp;lt;&amp;lt; &quot;\\n&quot; &amp;lt;&amp;lt; res[i].ct; for (auto j : res[i].data) { cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; j; } } return 0;} 首先使用map记录功能重复的代码块，然后自定义排序规则，将次数多的放到前面，然后再根据里面代码块数据来排序，然后打印即可#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;int n, m;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;matrix;int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; matrix = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(n + 1); unordered_map&amp;lt;int, int&amp;gt;um; for (int i = 1; i &amp;lt;= n; i++) { int t; cin &amp;gt;&amp;gt; t; vector&amp;lt;int&amp;gt;temp; while (t--) { int data; cin &amp;gt;&amp;gt; data; temp.push_back(data); } matrix[i] = temp; } int index = 1; vector&amp;lt;int&amp;gt;res; while (m--) { int t, x; cin &amp;gt;&amp;gt; t &amp;gt;&amp;gt; x; if (t == 1) { um[x] = index; res.push_back(index); } if (t == 2) { index = um[x]; } if (t == 0) { index = matrix[index][x - 1]; } } for (auto&amp;amp; i : res) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; index;} 这道题不怎么难，就是一个模拟题目，我们使用unordered_map存放存档点，然后用matrix来记录每个点可以去往的地方，用index去记录当前点的位置即可4.哲哲打游戏#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;int n, m;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;matrix;int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; matrix = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(n + 1); unordered_map&amp;lt;int, int&amp;gt;um; for (int i = 1; i &amp;lt;= n; i++) { int t; cin &amp;gt;&amp;gt; t; vector&amp;lt;int&amp;gt;temp; while (t--) { int data; cin &amp;gt;&amp;gt; data; temp.push_back(data); } matrix[i] = temp; } int index = 1; vector&amp;lt;int&amp;gt;res; while (m--) { int t, x; cin &amp;gt;&amp;gt; t &amp;gt;&amp;gt; x; if (t == 1) { um[x] = index; res.push_back(index); } if (t == 2) { index = um[x]; } if (t == 0) { index = matrix[index][x - 1]; } } for (auto&amp;amp; i : res) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; index;} 这道题不怎么难，就是一个模拟题目，我们使用unordered_map存放存档点，然后用matrix来记录每个点可以去往的地方，用index去记录当前点的位置即可" }, { "title": "2022天梯赛模拟赛", "url": "/posts/2022%E5%A4%A9%E6%A2%AF%E6%A8%A1%E6%8B%9F%E8%B5%9B/", "categories": "PTA", "tags": "题解, 天梯赛", "date": "2022-04-18 04:00:00 +0000", "snippet": "感谢各位关注~L11.自动编程#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int n; cin&amp;gt;&amp;gt;n; printf(&quot;print(%d)\\n&quot;,n);} 签到题2.太神奇了#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int a,b; cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; cout&amp;lt;&amp;lt;a+b-1&amp;lt;&amp;lt;endl;} 别看题目有点迷茫，其实就是给你两个数返回和减一3.洛希极限#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ double a,b,c; cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c; if(b==0) a*=2.455; else a*=1.26; printf(&quot;%.2lf &quot;,a); if(a&amp;lt;c) cout&amp;lt;&amp;lt;&quot;^_^&quot;&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&quot;T_T&quot;&amp;lt;&amp;lt;endl;} 简单的签到题目4.吃鱼还是吃肉​ #include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int n; cin&amp;gt;&amp;gt;n; while(n--) { int sex,hight,kg; cin&amp;gt;&amp;gt;sex&amp;gt;&amp;gt;hight&amp;gt;&amp;gt;kg; int hight_bz, kg_bz; if(sex==1) { hight_bz=130; kg_bz=27; }else { hight_bz=129; kg_bz=25; } if(hight&amp;lt;hight_bz) { cout&amp;lt;&amp;lt;&quot;duo chi yu! &quot;; }else if(hight==hight_bz) { cout&amp;lt;&amp;lt;&quot;wan mei! &quot;; }else { cout&amp;lt;&amp;lt;&quot;ni li hai! &quot;; } if(kg&amp;lt;kg_bz) { cout&amp;lt;&amp;lt;&quot;duo chi rou!&quot;&amp;lt;&amp;lt;endl; }else if(kg==kg_bz) { cout&amp;lt;&amp;lt;&quot;wan mei!&quot;&amp;lt;&amp;lt;endl; }else { cout&amp;lt;&amp;lt;&quot;shao chi rou!&quot;&amp;lt;&amp;lt;endl; } }} 签到题，按照题目意思输出打印即可5.不变初心数#include&amp;lt;iostream&amp;gt;using namespace std;int getData(int n){ int sum=0; while(n) { sum+=n%10; n/=10; } return sum;}int main(){ int n; cin&amp;gt;&amp;gt;n; while(n--) { int t; cin&amp;gt;&amp;gt;t; int res=getData(t*2); int flag=1; for(int i=3;i&amp;lt;=9;i++) { if(getData(i*t)!=res) { flag=0; break; } } if(flag) cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&quot;NO&quot;&amp;lt;&amp;lt;endl; }} 签到题，按照题目意思模拟即可6.字符串#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;int main(){ int n; cin &amp;gt;&amp;gt; n; while (n--) { string s; cin &amp;gt;&amp;gt; s; int size = s.size(); int flag = 1; for (int i = 0; i &amp;lt; size-1; i++) { char ch = s[i]; if (ch &amp;gt;= &#39;a&#39;&amp;amp;&amp;amp;ch &amp;lt;= &#39;z&#39;) { if (s[i + 1] != ch - &#39;a&#39; + &#39;A&#39;&amp;amp;&amp;amp;s[i + 1] != ch - 1) { flag = 0; break; } } else { if (s[i + 1] != ch - &#39;A&#39; + &#39;a&#39;&amp;amp;&amp;amp;s[i + 1] != ch + 1) { flag = 0; break; } } } if (flag) cout &amp;lt;&amp;lt; &quot;Y&quot; &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;N&quot; &amp;lt;&amp;lt; endl; }} 签到题目，按照题目意思模拟即可。因为题目给的都是英文字母，我们可以对a和Z直接进行加减后判断即可，不会出现比如a下一个是ascii96的情况7.矩阵下移#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;int main(){ int n, k, x; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; x; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;data(n + 1, vector&amp;lt;int&amp;gt;(n + 1)); for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) cin &amp;gt;&amp;gt; data[i][j]; } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;temp = data; int index = 1; for (int i = 2; i &amp;lt;= n; i=i+2) { for (int j = 1; j &amp;lt;= n; j++) { if (j + index &amp;lt;= n) { temp[j + index][i] = data[j][i]; if (j &amp;lt;= index) temp[j][i] = x; } } if (index == k) index = 0; index++; } for (int i = 1; i &amp;lt;= n; i++) { int sum = 0; for (int j = 1; j &amp;lt;= n; j++) sum += temp[i][j]; if (i != n) cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; &quot; &quot;; else cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl; }} 模拟题，我们如果按照2，4，6这个顺序去移动的话，势必会有一个问题，如果2把4或者其他覆盖了，下次要用到怎么办，我们可以再创一个矩阵，或者用数组去记录值8.均是素数#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;unordered_set&amp;gt;bool isPrime(int x){ if (x &amp;lt; 2) return false; for (int i = 2; i * i &amp;lt;= x; i++) { if (x % i == 0) return false; } return true;}int main(){ int l, r; cin &amp;gt;&amp;gt; l &amp;gt;&amp;gt; r; unordered_set&amp;lt;int&amp;gt;us; unordered_set&amp;lt;int&amp;gt;data; for (int i = l; i &amp;lt;= r; i++) { if (!us.count(i) &amp;amp;&amp;amp; isPrime(i)) { us.insert(i); } } int res = 0; for (auto&amp;amp; a : us) { for (auto&amp;amp; b : us) { if (a == b) continue; for (auto&amp;amp; c : us) { if (a == c || b == c) continue; if (isPrime(a*b+c)&amp;amp;&amp;amp; isPrime(a * c + b)&amp;amp;&amp;amp; isPrime(c * b + a)) res++; } } } cout &amp;lt;&amp;lt; res / 6 &amp;lt;&amp;lt; endl;} 对于这道题目，如果我们用正常的方法，对于[l,r]区间的数进行三层for循环，对于每一个 a,b,c ，我们如果每次在循环里面判断他是否为素数，会产生较大的时间，会导致运行时间超时。我们可以提前将[l,r]的素数存入哈希表，然后遍历这个哈希表即可加快速度，另外，对于a,b,c的全排列只能算一种，我们要在最后结果那里除以一个6(A的3 2)L21.盲盒包装流水线#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;#include&amp;lt;stack&amp;gt;int main(){ int n, s; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; s; unordered_map&amp;lt;string, int&amp;gt;um;//纪录对应盒子的次数 vector&amp;lt;string&amp;gt;box;//存放盒子编号以及顺序 for (int i = 0; i &amp;lt; n; i++) { string s; cin &amp;gt;&amp;gt; s; box.push_back(s); } int index = 0; stack&amp;lt;int&amp;gt;data; for (int i = 1; i &amp;lt;=n; i++) { int t; cin &amp;gt;&amp;gt; t; data.push(t); if (i % s == 0)//栈满了 { while (!data.empty())//推入到对应的盒子中 { int temp = data.top(); data.pop(); um[box[index]] = temp; index++; } } } int t; cin &amp;gt;&amp;gt; t; while (t--) { string str; cin &amp;gt;&amp;gt; str; if (um[str]) cout &amp;lt;&amp;lt; um[str] &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;Wrong Number&quot; &amp;lt;&amp;lt; endl; }} 看题目我们可以用栈进行模拟，每次当栈满时，进行装盒操作，然后使用哈希表记录盒子放的是什么，因为题目给出盲盒数量肯定是栈最大容量的倍数，我们可以直接遍历，当i为s的倍数的时候(i从1开始)，即是出栈的时候，然后获取盒子编号进行判断2.点赞狂魔#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;set&amp;gt;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;struct node { string name; int real; int size;};bool cmp(node x, node y){ if (x.real != y.real) return x.real &amp;gt;y.real; if (x.size != y.size) return x.size &amp;lt; y.size; return false;}int main(){ vector&amp;lt;node&amp;gt;vn; int t; cin &amp;gt;&amp;gt; t; while (t--) { string name; int size; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; size; set&amp;lt;int&amp;gt;s; for (int i = 0; i &amp;lt; size; i++) { int t; cin &amp;gt;&amp;gt; t; s.insert(t); } node mynode; mynode.name = name; mynode.real = s.size(); mynode.size = size; vn.push_back(mynode); } sort(vn.begin(), vn.end(),cmp); vector&amp;lt;string&amp;gt;res(3, &quot;-&quot;); for (int i = 0; i &amp;lt; min(3, (int)vn.size()); i++) { res[i] = vn[i].name; } cout &amp;lt;&amp;lt; res[0]; for (int i = 1; i &amp;lt; 3; i++) { cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; res[i]; } cout &amp;lt;&amp;lt; endl;} 一道模拟题，我们可以定义一个类，里面包含姓名，不同标签数量和标签数量，可以使用set去重复，然后再sort排序取前三，如果个数不包含三个，则用 - 取代替名字3.浪漫侧影#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;queue&amp;gt;class treenode {public: int val; treenode* left; treenode* right; treenode():left(nullptr),right(nullptr),val(0){} treenode(int val) :left(nullptr), right(nullptr), val(val) {}};vector&amp;lt;int&amp;gt;inr;vector&amp;lt;int&amp;gt;post;treenode* build(int root, int start, int end){ if (start &amp;gt; end)//为空 return nullptr; int i = end; while (i &amp;gt; start &amp;amp;&amp;amp; inr[i] != post[root]) i--; treenode* t = new treenode(); t-&amp;gt;val = post[root]; t-&amp;gt;left = build(root-1-end+i, start, i - 1); t-&amp;gt;right = build(root - 1, i+1, end); return t;}int main(){ int n; cin &amp;gt;&amp;gt; n; inr = vector&amp;lt;int&amp;gt;(n); post = vector&amp;lt;int&amp;gt;(n); for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; inr[i]; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; post[i]; treenode* root = build(n - 1, 0, n - 1); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;res; queue&amp;lt;treenode*&amp;gt;q; q.push(root); while (!q.empty()) { int size = q.size(); vector&amp;lt;int&amp;gt;temp; for (int i = 0; i &amp;lt; size; i++) { auto t = q.front(); q.pop(); temp.push_back(t-&amp;gt;val); if (t-&amp;gt;left) q.push(t-&amp;gt;left); if (t-&amp;gt;right) q.push(t-&amp;gt;right); } res.push_back(temp); } cout &amp;lt;&amp;lt; &quot;R:&quot;; for (auto&amp;amp; i : res) { cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i.back(); } cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;L:&quot;; for (auto&amp;amp; i : res) { cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i[0]; } cout &amp;lt;&amp;lt; endl;} 我们发现左右侧影，分别是该层的最左边和最右边，我们可以记录下树的层序遍历，那层的第一个和最后一个就是对应的该层的左影和右影，这道题还考察了递归建树，根据中序遍历(左 根 右)和后序遍历(左 右 根)，我们可以知道后序遍历每一段最后的值就是根节点的值，然后我们可以通过根节点的值去划分左右子树4.哲哲打游戏#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;int n, m;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;matrix;int main(){ cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; matrix = vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;(n + 1); unordered_map&amp;lt;int, int&amp;gt;um; for (int i = 1; i &amp;lt;= n; i++) { int t; cin &amp;gt;&amp;gt; t; vector&amp;lt;int&amp;gt;temp; while (t--) { int data; cin &amp;gt;&amp;gt; data; temp.push_back(data); } matrix[i] = temp; } int index = 1; vector&amp;lt;int&amp;gt;res; while (m--) { int t, x; cin &amp;gt;&amp;gt; t &amp;gt;&amp;gt; x; if (t == 1) { um[x] = index; res.push_back(index); } if (t == 2) { index = um[x]; } if (t == 0) { index = matrix[index][x - 1]; } } for (auto&amp;amp; i : res) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } cout &amp;lt;&amp;lt; index;} 这道题不怎么难，就是一个模拟题目，我们使用unordered_map存放存档点，然后用matrix来记录每个点可以去往的地方，用index去记录当前点的位置即可L31.直捣黄龙#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;map&amp;gt;int N, K;string s, e;class Node {public: string name; int size; vector&amp;lt;pair&amp;lt;string, int&amp;gt;&amp;gt;data;};unordered_map&amp;lt;string, Node&amp;gt;um;vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;res;vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;res1;vector&amp;lt;string&amp;gt;temp;unordered_map&amp;lt;string, int&amp;gt;vis;map&amp;lt;vector&amp;lt;string&amp;gt;, int&amp;gt;kills;unordered_map&amp;lt;int, vector&amp;lt;string&amp;gt;&amp;gt;res2;int min_jl = INT32_MAX;void dfs(string name,int jl,int size){ if (name == e) { if (jl &amp;lt; min_jl) { res.clear(); min_jl = jl; res.push_back(temp); kills.clear(); kills[temp] = size; } else if (jl == min_jl) { res.push_back(temp); kills[temp] = size; } } auto node = um[name]; for (auto&amp;amp; tt : node.data) { if (vis[tt.first]) continue; temp.push_back(tt.first); vis[tt.first] = 1; dfs(tt.first, jl + tt.second,size+um[tt.first].size); vis[tt.first] = 0; temp.pop_back(); }}int main(){ cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K &amp;gt;&amp;gt; s &amp;gt;&amp;gt; e; for (int i = 0; i &amp;lt; N - 1; i++) { string name; int size; cin &amp;gt;&amp;gt; name &amp;gt;&amp;gt; size; Node n; n.size = size; um[name] = n; } while (K--) { string sname, ename; int jl; cin &amp;gt;&amp;gt; sname &amp;gt;&amp;gt; ename; cin &amp;gt;&amp;gt; jl; um[sname].data.push_back({ ename,jl }); um[ename].data.push_back({ sname,jl }); } temp.push_back(s); dfs(s,0,0); int max_data = res[0].size(); for (int i = 1; i &amp;lt; res.size(); i++) { if (res[i].size() &amp;gt; max_data) max_data = res[i].size(); } for (int i = 0; i &amp;lt; res.size(); i++) { if (res[i].size() == max_data) res1.push_back(res[i]); } //res1存放距离一致，解放数量一致的数据 int maxsum = INT32_MIN; for (auto&amp;amp; i : res1) { int sum = kills[i]; res2[sum] = i; if (sum &amp;gt; maxsum) maxsum = sum; } auto result = res2[maxsum]; cout &amp;lt;&amp;lt; result[0]; for (int i = 1; i &amp;lt; result.size(); i++) { cout &amp;lt;&amp;lt; &quot;-&amp;gt;&quot; &amp;lt;&amp;lt; result[i]; } cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; res.size() &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; min_jl &amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt; maxsum &amp;lt;&amp;lt; endl;} 这道题模拟，我们可以用res记录到达目标点距离最短的集合，然后再通过筛选得到解放点多的集合放入res1，然后遍历res1取寻找杀敌最多的，然后打印输出即可，注意min_jl要开大点不然有个测试点可能会比结果小2.拼题A打卡奖励#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;string.h&amp;gt;vector&amp;lt;int&amp;gt;w(1001);vector&amp;lt;int&amp;gt;v(1001);vector&amp;lt;int&amp;gt;dp(40 * 1001,0x3f3f3f3f3f);//int w[1001],v[1001],dp[40*1001];int main(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for (int i = 1; i &amp;lt;= n; i++) cin &amp;gt;&amp;gt; w[i]; int sum = 0; for (int i = 1; i &amp;lt;= n; i++) { cin &amp;gt;&amp;gt; v[i]; sum += v[i]; } //memset(dp,0x3f,sizeof(dp)); dp[0] = 0; for (int i = 1; i &amp;lt;= n; i++) { for (int j = sum; j &amp;gt;= v[i]; j--) { if (dp[j - v[i]] + w[i] &amp;lt; dp[j]) dp[j] = dp[j - v[i]] + w[i]; } } while (dp[sum] &amp;gt; m) { sum--; } cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;} 背包问题，dp[j]代表的是，实现j价值所需要的时间，得到公式为dp[j]=min(dp[j],dp[j-v[i]]+w[i])" }, { "title": "2020天梯赛决赛", "url": "/posts/2020%E5%A4%A9%E6%A2%AF%E5%86%B3%E8%B5%9B/", "categories": "PTA", "tags": "题解, 天梯赛", "date": "2022-04-14 12:00:00 +0000", "snippet": "感谢各位关注~L11.嫑废话上代码#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ cout&amp;lt;&amp;lt;&quot;Talk is cheap. Show me the code.&quot;&amp;lt;&amp;lt;endl;} 简单的签到题2.猫是液体#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int a,b,c; cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c; cout&amp;lt;&amp;lt;a*b*c&amp;lt;&amp;lt;endl;} 简单的签到题3.洛希极限#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ double a,b,c; cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c; if(b==0) a*=2.455; else a*=1.26; printf(&quot;%.2lf &quot;,a); if(a&amp;gt;=c) cout&amp;lt;&amp;lt;&quot;T_T&quot;&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&quot;^_^&quot;&amp;lt;&amp;lt;endl; return 0;} 简单的签到题4.调和平均#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;int main(){ int n; double sum=0; cin&amp;gt;&amp;gt;n; for(int i=0;i&amp;lt;n;i++) { double t; cin&amp;gt;&amp;gt;t; sum+=1/t; } sum/=n; sum=1/sum; printf(&quot;%.2lf\\n&quot;,sum);} 简单的签到题5.胎压检测#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;int main(){ vector&amp;lt;int&amp;gt;data(4); for (int i =0 ; i &amp;lt; 4; i++) { cin &amp;gt;&amp;gt; data[i]; } int min_data,cz; cin &amp;gt;&amp;gt; min_data&amp;gt;&amp;gt;cz; int max_data = *max_element(data.begin(), data.end()); int cnt = 0;5 int dcnt = 0; int mydata; for (int i=0;i&amp;lt;4;i++) { if (max_data - data[i] &amp;gt; cz) { mydata = i; cnt++; } if (data[i] &amp;lt; min_data) { mydata = i; dcnt++; } } if (cnt == 0 &amp;amp;&amp;amp; dcnt == 0) { cout &amp;lt;&amp;lt; &quot;Normal&quot; &amp;lt;&amp;lt; endl; } else if (cnt + dcnt == 1) { cout &amp;lt;&amp;lt; &quot;Warning: please check #&quot; &amp;lt;&amp;lt; mydata+1&amp;lt;&amp;lt; &quot;!&quot;; } else { cout &amp;lt;&amp;lt; &quot;Warning: please check all the tires!&quot; &amp;lt;&amp;lt; endl; } return 0;} 简单的签到题,用cnt和dcnt来记录轮胎故障的数量6.吃火锅#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;#include&amp;lt;vector&amp;gt;int main(){ int ans = 0; vector&amp;lt;int&amp;gt;cnt; while (1) { string s; getline(cin, s); if (s == &quot;.&quot;) break; ans++; if (s.find(&quot;chi1 huo3 guo1&quot;) != -1) cnt.push_back(ans); } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; if (cnt.size()) cout &amp;lt;&amp;lt; cnt[0]&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;cnt.size() &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; &quot;-_-#&quot; &amp;lt;&amp;lt; endl; return 0;} 简单的签到题，注意获取行要用getline(cin,str)，ans来记录第几个，如果找到则推入cnt7.前世档案#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int n,m; cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; while(m--) { string s; cin&amp;gt;&amp;gt;s; int res=1; for(auto&amp;amp;ch:s) { if(ch==&#39;y&#39;) res=2*res-1; else res=2*res; } cout&amp;lt;&amp;lt;res&amp;lt;&amp;lt;endl; }} 一道简单的签到题目，只需要掌握其中规律，即向左是乘以2-1，向右乘以28.刮刮彩票#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;int main(){ unordered_map&amp;lt;int, int&amp;gt;map = { {6,10000},{7,36},{8,720},{9,360},{10,80},{11,252}, {12,108},{13,72},{14,54},{15,180},{16,72},{17,180},{18,119},{19,36},{20,306}, {21,1080},{22,144},{23,1800},{24,3600} }; int a[4][4]; pair&amp;lt;int, int&amp;gt;data; vector&amp;lt;bool&amp;gt;vis(10, false); for (int i = 1; i &amp;lt; 4; i++) { for (int j = 1; j &amp;lt; 4; j++) { cin &amp;gt;&amp;gt; a[i][j]; vis[a[i][j]] = true; if (a[i][j] == 0) data = { i,j }; } } for (int i = 1; i &amp;lt; 10; i++) { if (!vis[i]) a[data.first][data.second] = i; } for (int i = 0; i &amp;lt; 3; i++) { int x, y; cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y; cout &amp;lt;&amp;lt; a[x][y] &amp;lt;&amp;lt; endl; } int sum = 0; int t; cin &amp;gt;&amp;gt; t; if (t &amp;lt;= 3) { for (int i = 1; i &amp;lt; 4; i++) { sum += a[t][i]; } } else if (t &amp;lt;= 6) { for (int i = 1; i &amp;lt; 4; i++) { sum += a[i][t - 3]; } } else if (t == 7) { sum += a[1][1] + a[2][2] + a[3][3]; } else { sum += a[1][3] + a[2][2] + a[3][1]; } cout &amp;lt;&amp;lt; map[sum] &amp;lt;&amp;lt; endl;} 我们发现彩票的点数是从1-9，而数据会给你1-9八个数和一个0，可以发现那个0所在的位置就是1-9没有出现过的值，我们可以用一个数组来纪录是否出现，然后进行补充，可以用哈希表来存储对应点数和的金币数目L21.简单计算器#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;stack&amp;gt;int main(){ stack&amp;lt;int&amp;gt;s1; stack&amp;lt;char&amp;gt;s2; int n; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) { int t; cin &amp;gt;&amp;gt; t; s1.push(t); } for (int i = 0; i &amp;lt; n-1; i++) { char t; cin &amp;gt;&amp;gt; t; s2.push(t); } int flag = 1; while (!s2.empty()) { char ch = s2.top();s2.pop(); int a = s1.top(); s1.pop(); int b = s1.top(); s1.pop(); if (ch == &#39;+&#39;) b = b + a; if (ch == &#39;-&#39;) b = b - a; if (ch == &#39;*&#39;) b = b * a; if (ch == &#39;/&#39;) { if (a == 0) { printf(&quot;ERROR: %d/0\\n&quot;, b); return 0; } else b = b / a; } s1.push(b); } if (flag) cout &amp;lt;&amp;lt; s1.top() &amp;lt;&amp;lt; endl; return 0;} 一道简单的模拟题，模拟即可2.口罩发放#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;unordered_map&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;set&amp;gt;struct node{ string name; string sfz; int body; int hh; int mm; int pos;};unordered_map&amp;lt;string, int&amp;gt;day;//口罩发放时间bool cmp(node x, node y){ if (x.hh != y.hh) return x.hh &amp;lt; y.hh; else if (x.mm != y.mm) return x.mm &amp;lt; y.mm; return x.pos &amp;lt; y.pos;}vector&amp;lt;node&amp;gt;request;vector&amp;lt;node&amp;gt;hz;int main(){ int d, p; cin &amp;gt;&amp;gt; d &amp;gt;&amp;gt; p; vector&amp;lt;node&amp;gt;res; for (int i = 1; i &amp;lt;= d; i++) { int n, m;//申请数和口罩数量 cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; for(int j=1;j&amp;lt;=n;j++) { node t; char c; cin &amp;gt;&amp;gt; t.name &amp;gt;&amp;gt; t.sfz &amp;gt;&amp;gt; t.body &amp;gt;&amp;gt; t.hh &amp;gt;&amp;gt; c &amp;gt;&amp;gt; t.mm; t.pos = j; int len = t.sfz.size(); if (len != 18) continue; int flag = 0; for (auto&amp;amp; ch : t.sfz) { if (!isdigit(ch)) { flag = 1; break; } } if (flag) continue; if (t.body) hz.push_back(t); request.push_back(t); } sort(request.begin(), request.end(),cmp); int len = request.size(); for (int j = 0; j &amp;lt; len; j++) { if (m == 0) break; if (day[request[j].sfz] == 0 || i &amp;gt;= p + day[request[j].sfz] + 1) { res.push_back(request[j]); day[request[j].sfz] = i; m--; } } request.clear(); } for (auto&amp;amp; i : res) cout &amp;lt;&amp;lt; i.name &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; i.sfz &amp;lt;&amp;lt; endl; set&amp;lt;string&amp;gt;s; for (int x = 0; x &amp;lt; hz.size(); x++) { if (!s.count(hz[x].sfz)) { cout &amp;lt;&amp;lt; hz[x].name &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; hz[x].sfz &amp;lt;&amp;lt; endl; s.insert(hz[x].sfz); } }} 按照题目模拟，用哈希表记录每次领取的时间，然后记录病患，最后判断是否重复输出3.完全二叉树的层序遍历" }, { "title": "牛客小白月赛47", "url": "/posts/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B47/", "categories": "牛客", "tags": "牛客小白赛, 题解", "date": "2022-04-08 04:00:00 +0000", "snippet": "感谢关注A.牛牛的装球游戏#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int n; double pi = 3.141592653589; cin &amp;gt;&amp;gt; n; while (n--) { int r, h; cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; h; int t = h / r/2; double data = 0; data += pi * r * r * h; data -= (4.0 / 3) * pi * r * r * r*t; printf(&quot;%.3lf\\n&quot;, data); } return 0;} 简单的签到题目B.牛牛的数字集合#include&amp;lt;iostream&amp;gt;using namespace std;long mod=1e+9+7;int main(){ long long sum = 1; int n; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; i++) { int t; cin &amp;gt;&amp;gt; t; sum= sum*t%mod; } cout &amp;lt;&amp;lt; sum%mod &amp;lt;&amp;lt; endl; return 0;} 需要使用数学的思想，假设我们有n个x进行操作，全部分为一组的时候是x的n次，分为n组的时候是n*x的n次，发现分成一组的情况最小，在带入多组数据可得为1组的时候最小，注意这个的sum每次乘起来都要对mod取余，不然可能会超出数据范围而导致错误 证明:如果分成了m个集合那么，最后一个集合的m次肯定大于只划分一个集合的大小C.小猫排队#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;int main(){ int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;int&amp;gt;data(n);//用来获取数据 int index = -1; int cc = 0; for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; data[i]; int key;//获取小猫的萌值 cin &amp;gt;&amp;gt; key; reverse(data.begin(), data.end());//反转数据方便操作 vector&amp;lt;int&amp;gt;max_index; for (int i=0;i&amp;lt;n;i++) { if (data[i] &amp;gt; key) { max_index.push_back(i);//获取可以交换位置的下标 } } int start = 0;//交换位置数组的下标 while (index != n) { if (start &amp;lt; max_index.size() &amp;amp;&amp;amp; max_index[start] &amp;lt; n) {//start要在0到max_index-1之间，并且小猫跳的位置要小于末尾的位置 index = max_index[start]; start++; } n--; cc++; } cout &amp;lt;&amp;lt; cc &amp;lt;&amp;lt; endl;} 阅读题目，我们可以使用模拟的方法，我们可以将数据存入vector，然后在反转，问题就转化为小猫跳到n坐标需要的次数，每次n–意味着开头元素的出列，然后用max_index存放小猫可以跳跃的位置，如果跳跃位置上的元素没有出列，那么小猫就会跳到这个元素D.造桥#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;int main(){ int T; cin &amp;gt;&amp;gt; T; while (T--) { int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;int&amp;gt;left(n);//存放第n+1个字符串的首字母 vector&amp;lt;int&amp;gt;right(n);//存放第n+1字符串的末尾字母 vector&amp;lt;int&amp;gt;len(n);//存放第n+1字符串的数字 vector&amp;lt;int&amp;gt;mx(26, 0);//存放以字符对应的右边字符的长度 for (int i = 0; i &amp;lt; n; i++) { string s; cin &amp;gt;&amp;gt; s; len[i] = s.size(); left[i] = s[0] - &#39;a&#39;; right[i] = s[len[i] - 1] - &#39;a&#39;; } for (int i = 0; i &amp;lt; n; i++) { mx[right[i]] = max(mx[right[i]], mx[left[i]] + len[i]); } int max = 0; for (auto&amp;amp; i : mx) { if (i &amp;gt; max) max = i; } cout &amp;lt;&amp;lt; max &amp;lt;&amp;lt; endl; } return 0;} ​ 一道典型的动态规划算法，这道题我们要以字符为结尾当作DP的条件，dp公式为以ch结尾的最大值等于以ch结尾的最大值，或者当前字符串前面的ch结尾的最大值加上当前字符串E.牛牛的方格图#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;#include&amp;lt;unordered_map&amp;gt;class Color {public: int min_i; int max_i; int min_j; int max_j; int size; Color() :min_j(INT32_MAX), max_j(INT32_MIN), min_i(INT32_MAX), max_i(INT32_MIN),size(0) {}};int main(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;data(n, vector&amp;lt;int&amp;gt;(m)); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;d(n+1, vector&amp;lt;int&amp;gt;(m+1)); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;sum(n + 1, vector&amp;lt;int&amp;gt;(m + 1)); unordered_map&amp;lt;int,Color&amp;gt;colors; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { cin &amp;gt;&amp;gt; data[i][j]; int t = data[i][j]; colors[t].max_i = max(colors[t].max_i, i); colors[t].max_j = max(colors[t].max_j, j); colors[t].min_i = min(colors[t].min_i, i); colors[t].min_j = min(colors[t].min_j, j); colors[t].size++; } } for (auto&amp;amp; i : colors) { if (i.second.size &amp;gt; 1) { int x1 = i.second.min_i; int y1 = i.second.min_j; int x2 = i.second.max_i; int y2 = i.second.max_j; int size = i.second.size; d[x1][y1]++; d[x1][y2+1]--; d[x2 + 1][y1]--; d[x2 + 1][y2 + 1]++; } } int ans = 0; for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= m; j++) { sum[i][j] = d[i - 1][j - 1] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]; if (sum[i][j] == 0) ans++; } } cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl; return 0;} 思维题目：对于某种颜色，我们只需要记录最小行列坐标，最大行列坐标，这些组成的矩形就是该颜色的范围，然后再根据差分数组操作，判断哪个位置没有影响过，没有影响的位置就是没有覆盖的位置 差分：n个数进行m次操作，每次形如(l,r,add)表示将[l,r]之间的数字+=add，差分数组：b[i]=a[i]-a[i-1] 如上图，在x1，y1和x2，y2组成的矩阵中，根据差分的定义，在x1，y1处加一表式再以x1，y1为左顶点的数都加了1，为了防止矩阵外的数字产生变化，我们应该在适当的位置减一，即(x1,y2+1)和(x2+1,y1)然后(x2+1,y2+1)处产生了重复减一所以我们应该加一F.缆车 阅读题目，我们可以发现题目的意思就是从图形说明中的星星点(中转点)为了到(三角形点)需要添加一条路径，而且要路径和最，需要树dp和lca和dfs基础才能写出 情况一:星不能到达所有三角—-连的边一定是星到星子树内以外的所有三角点的lca" }, { "title": "2020天梯赛模拟赛", "url": "/posts/2020%E5%A4%A9%E6%A2%AF%E8%B5%9B%E6%A8%A1%E6%8B%9F%E8%B5%9B/", "categories": "PTA", "tags": "题解, 天梯赛", "date": "2022-04-05 07:27:00 +0000", "snippet": "感谢各位关注~L11.新世界(5分)#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ cout &amp;lt;&amp;lt; &quot;Hello World\\nHello New World&quot;; return 0;}/* 签到题*/2.打折#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int price, zk; cin &amp;gt;&amp;gt; price &amp;gt;&amp;gt; zk; printf(&quot;%.2lf&quot;, price * zk / 10.0); return 0;}/* 这道题要注意小数*/3.奇偶分家#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int n; cin &amp;gt;&amp;gt; n; int js = 0, os = 0; while (n--) { int data; cin &amp;gt;&amp;gt; data; if (data % 2 == 0) os++; else js++; } cout &amp;lt;&amp;lt; js &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; os &amp;lt;&amp;lt; endl; return 0;}/* 签到题*/4.冠军魔术#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;cmath&amp;gt;int main(){ int crads, times; cin &amp;gt;&amp;gt; crads &amp;gt;&amp;gt; times; crads = crads * pow(2, times / 2); if (times % 2 == 0) cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; crads; else cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; crads; return 0;}/* 通过阅读题目我们可以得知，一次来回硬币(纸牌)的数量会翻两倍，并且奇数次的时候会变成硬币，我们可以通过pow函数来计算cards的数量，并且对次数进行对2去模来判断cards是硬币还是函数*/5.判断题#include&amp;lt;vector&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;int main(){ int n, m; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m; vector&amp;lt;int&amp;gt;grade(m);//存放每题的分数 vector&amp;lt;int&amp;gt;answer(m);//存放题目的答案 for (int i = 0; i &amp;lt;m ; i++)//获取成绩的值 { cin &amp;gt;&amp;gt; grade[i]; } for (int i = 0; i &amp;lt; m; i++)//获取题目的正确答案 { cin &amp;gt;&amp;gt; answer[i]; } for (int i = 0; i &amp;lt; n; i++) { int res = 0; for (int j = 0; j &amp;lt; m; j++) { int t; cin &amp;gt;&amp;gt; t; if (t == answer[j]) res += grade[j]; } cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl; } return 0;}/* 通过阅读题目我们可以得知，我们需要定义个数组存放题目的答案和分数，然后判断学生是否答对，然后对其进行累加*/6.检查密码#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;int main(){ int n; cin &amp;gt;&amp;gt; n; string s; int flag = 0; getchar(); while (n--) { getline(cin, s); if (s.length() &amp;lt; 6) { if (flag) cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &quot;Your password is tai duan le.&quot; ; } else { int digst = 0, letter = 0, other = 0, dot = 0; //定义digst，letter，other，dot分别存放字母，数字，其他 //字符和小数点的数目 for (auto&amp;amp; ch : s) { if (ch &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; ch &amp;lt;= &#39;z&#39; || ch &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; ch &amp;lt;= &#39;Z&#39;) letter++; else if (ch &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; ch &amp;lt;= &#39;9&#39;) digst++; else if (ch == &#39;.&#39;) dot++; else other++; } if (other &amp;gt; 0 || digst == 0 &amp;amp;&amp;amp; letter == 0) { if (flag) cout &amp;lt;&amp;lt; &quot;\\n&quot;; cout &amp;lt;&amp;lt; &quot;Your password is tai luan le.&quot;; } else if (digst == 0) { if (flag) cout &amp;lt;&amp;lt; &quot;\\n&quot;; cout &amp;lt;&amp;lt; &quot;Your password needs shu zi.&quot;; } else if (letter == 0) { if (flag) cout &amp;lt;&amp;lt; &quot;\\n&quot;; cout &amp;lt;&amp;lt; &quot;Your password needs zi mu.&quot;; } else { if (flag) cout &amp;lt;&amp;lt; &quot;\\n&quot;; cout &amp;lt;&amp;lt; &quot;Your password is wan mei.&quot;; } } flag = 1; } return 0;}/* 注意：我们不能通过cin&amp;gt;&amp;gt;s这种方式获取字符串，因为字符串中可能含有空格，cin会忽略空格，我们要用getline(cin,s)获取字符字符串，同时也要小心我们之前用cin获取n，缓冲区中还有\\n符号，下一次getline(cin,s)会获取到空，所以我们要用getchar()获取掉那个空字符*/7.谷歌的招聘#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;bool isPrime(int x){ if (x &amp;lt; 2) return false; for (int i = 2; i * i &amp;lt;= x; i++) { if (x % i == 0) return false; } return true;}int main(){ string s; int n, k; cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; cin &amp;gt;&amp;gt; s; for (int i = 0; i &amp;lt;= n - k; i++) { string str = s.substr(i, k); if (isPrime(stoi(str))) { cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; return 0; } } cout &amp;lt;&amp;lt; 404 &amp;lt;&amp;lt; endl; return 0;}/* 阅读题目，我们只需把那串数字当作字符串来看待，每次获取k个字符转化为数字然后判断是否为质数即可*/8.阅览室#include&amp;lt;iostream&amp;gt;using namespace std;bool st[1005];//st[i]记录第i本书的借出情况，1为借出int ti[1005];//ti[i]记录第i本书借出的时间int main(){ int n; cin &amp;gt;&amp;gt; n; double res = 0; int cnt = 0; while (n &amp;gt; 0) { int id, h, m, t; char ch; cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; ch; scanf(&quot;%d:%d&quot;, &amp;amp;h, &amp;amp;m); t = h * 60 + m; if (ch == &#39;S&#39;) { st[id] = 1; ti[id] = t; } if (ch == &#39;E&#39; &amp;amp;&amp;amp; st[id] == 1) { res += t - ti[id]; st[id] = 0; cnt++; } if (id == 0) { for (int i = 0; i &amp;lt; 1005; i++) st[i] = 0; if (cnt &amp;gt; 0) res /= cnt; printf(&quot;%d %.0lf\\n&quot;, cnt, res); n--; res = cnt = 0; } }}/* 简单的模拟题，注意输出的为整数，要忽略单个的s和E情况*/L21.出栈序列的合法性#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;string&amp;gt;#include&amp;lt;stack&amp;gt;int main(){ int m, n, k; cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k; for (int i = 0; i &amp;lt; k; i++) { stack&amp;lt;int&amp;gt;s; bool flag = true; int start = 1; for (int j = 0; j &amp;lt; n; j++) { int num; cin &amp;gt;&amp;gt; num; while (start&amp;lt;=num) { s.push(start++); } if (!s.empty() &amp;amp;&amp;amp; s.size()&amp;lt;=m &amp;amp;&amp;amp; num == s.top()) { s.pop(); } else { flag = false; } } if (flag) { cout &amp;lt;&amp;lt; &quot;YES&quot; &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &quot;NO&quot; &amp;lt;&amp;lt; endl; } } return 0;}/* 直接使用模拟的方法，用start记录已经入栈到的数字，当入栈小于输出的树的时候，将其补充到出的数，然后数小于栈顶的时候，判断是否和栈顶相等，不相等说明错误*/2.抢红包#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;vector&amp;gt;#include&amp;lt;algorithm&amp;gt;class Person {public: int id; int money; int sum; Person() { } Person(int _id) :id(_id) { money = 0; sum = 0; }};int main(){ int n; cin &amp;gt;&amp;gt; n; vector&amp;lt;Person&amp;gt;data(n); for (int i = 0; i &amp;lt; n; i++) { Person p(i+1); data[i] = p; } for (int i = 0; i &amp;lt;n; i++) { int count; cin &amp;gt;&amp;gt; count; while (count--) { int id, money; cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; money; data[i].money -= money; data[id-1].money += money; data[id - 1].sum++; } } sort(data.begin(), data.end(), [](const Person&amp;amp; p1, const Person&amp;amp; p2) { if (p1.money== p2.money) { if (p1.sum == p2.sum) { return p1.id &amp;lt; p2.id; } return p1.sum &amp;gt; p2.sum; } else return p1.money &amp;gt; p2.money; }); for (auto&amp;amp; p : data) { printf(&quot;%d %.2lf\\n&quot;, p.id, p.money / 100.0); }}/* 模拟题，只需要使用结构体进行模拟，然后存放在data里面使用lambda表达式进行排序*/3.二叉搜索树的2层结点统计#include&amp;lt;iostream&amp;gt;using namespace std;#include&amp;lt;queue&amp;gt;class TreeNode {public: int val; TreeNode* left; TreeNode* right; TreeNode() :val(0), left(nullptr), right(nullptr){} TreeNode(int _val):val(_val),left(nullptr),right(nullptr){}};void addNode(TreeNode* root,int _val){ while (1) { if (_val &amp;lt;= root-&amp;gt;val) { if (root-&amp;gt;left == nullptr) { root-&amp;gt;left = new TreeNode(_val); return; } root = root-&amp;gt;left; } else { if (root-&amp;gt;right == nullptr) { root-&amp;gt;right = new TreeNode(_val); return; } root = root-&amp;gt;right; } }}/*输出二叉树调试void fun(TreeNode* root){ if (root != nullptr) { cout &amp;lt;&amp;lt; root-&amp;gt;val &amp;lt;&amp;lt; endl; fun(root-&amp;gt;left); fun(root-&amp;gt;right); }}*/int main(){ int n; cin &amp;gt;&amp;gt; n; n--; int t; cin &amp;gt;&amp;gt; t; TreeNode* root = new TreeNode(t); while (n--) { int t; cin &amp;gt;&amp;gt; t; addNode(root, t); } vector&amp;lt;int&amp;gt;data; queue&amp;lt;TreeNode*&amp;gt;q; q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i &amp;lt; size; i++) { TreeNode* p = q.front(); q.pop(); if (p-&amp;gt;left != nullptr) q.push(p-&amp;gt;left); if (p-&amp;gt;right != nullptr) q.push(p-&amp;gt;right); } data.push_back(size); } if (data.size() &amp;gt;= 2) cout &amp;lt;&amp;lt; data[data.size() - 1] + data[data.size() - 2] &amp;lt;&amp;lt; endl; else cout &amp;lt;&amp;lt; data[0] &amp;lt;&amp;lt; endl; return 0;}/* 这题我们可以先构建二叉搜索树，然后再用广度遍历将数据存入vector&amp;lt;int&amp;gt;然后用计算最后两个位置的和，计算和的时候要判断他是否为1个，不然会出现错误*/" }, { "title": "你好，世界！", "url": "/posts/hello-world/", "categories": "随笔", "tags": "生活", "date": "2022-03-26 02:34:00 +0000", "snippet": "感谢关注～这里可以放代码片段噢～//代码片段int main(){ hello world;}" } ]
